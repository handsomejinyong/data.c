#include <stdio.h>
#include <stdlib.h>

typedef char TElement;
typedef struct BinTrNode {
	TElement data;
	struct BinTrNode* left;
	struct BinTrNode* right;
}TNode;
TNode* root;

void init_tree() { root = NULL; }
int is_empty_tree() { return root == NULL; }
TNode* get_root() { return root; }

TNode* create_tree(TElement val, TNode* l, TNode* r)
{
	TNode* n = (TNode*)malloc(sizeof(TNode));
	n->data = val;
	n->left = l;
	n->right = r;
	return n;
}


void preorder(TNode* n)
{

	if (n != NULL) {
		printf("[%c]", n->data);
		preorder(n->left);
		preorder(n->right);
	}
}

void inorder(TNode* n)
{
	if (n != NULL) {
		inorder(n->left);
		printf("[%c]", n->data);
		inorder(n->right);
	}
}
void postorder(TNode* n)
{
	if (n != NULL) {
		postorder(n->left);
		postorder(n->right);
		printf("[%c]", n->data);
	}
}
#define MAX_QUEUE_SIZE 100
typedef TNode* Element;
Element data[MAX_QUEUE_SIZE];

int front;
int rear;

void error(char* str)
{
	printf("%s\n", str);
	exit(1);
}

void init_queue() { front = rear = 0; }
int is_empty() { return front == rear; }
int is_full() { return (rear + 1) % MAX_QUEUE_SIZE == front; }
int size() { return (rear - front + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE; }

void enqueue(Element val)
{
	if (is_full())
		error("큐 포화 에러");
	rear = (rear + 1) % MAX_QUEUE_SIZE;
	data[rear] = val;
}

Element dequeue()
{
	if (is_empty())
		error("큐 공백 에러");
	front = (front + 1) % MAX_QUEUE_SIZE;
	return data[front];
}
Element peek()
{
	if (is_empty())
		error("큐 공백 에러");
	return data[(front + 1) % MAX_QUEUE_SIZE];
}
void levelorder(TNode* root)
{
	TNode* n;

	if (root == NULL) return;
	init_queue();
	enqueue(root);
	while (!is_empty()) {
		n = dequeue();
		if (n != NULL) {
			printf("[%c]", n->data);
			enqueue(n->left);
			enqueue(n->right);
		}
	}
}
int count_node(TNode* n)
{
	if (n == NULL)return 0;
	return 1 + count_node(n->left) + count_node(n->right);
}

int count_leaf(TNode* n)
{
	if (n == NULL)return 0;
	if (n->left == NULL && n->right == NULL)return 1;
	else return count_leaf(n->left) + count_leaf(n->right);
}
int calc_height(TNode* n)
{
	int hLeft, hRight;
	if (n == NULL)return 0;
	hLeft = calc_height(n->left);
	hRight = calc_height(n->right);
	return (hLeft > hRight) ? hLeft + 1 : hRight + 1;
}

int is_complete_binary_tree()
{

}

int level(TNode* n)	//레벨 구하기 연산
{
	if (n == NULL) return 0;

	int lLv = level(n->left);
	int rLv = level(n->right);
	printf("노드의 레벨은 %d\n", rLv);

	if (lLv > rLv)return lLv + 1;
	else return rLv + 1;
}
int get_height(TNode* n)
{
	int height = 0;
	if (n != NULL)
		height = 1 + max(get_height(n->left), get_height(n->right));
	return height;
}
int is_balanced(TNode* n)	//균형 검사
{
	int b;
	if (n == NULL) return 1;
	b = get_height(n->left) - get_height(n->right);
	if (b > 1 || b < -1)
		return 0;
	else
		return (is_balanced(n->left) && is_balanced(n->right));
}
int treeDepth(TNode* n)
{
	if (!n) {
		return 0;
	}
	else {
		int lDepth = treeDepth(n->left);
		int rDepth = treeDepth(n->right);
		if (lDepth > rDepth) {
			return lDepth + 1;
		}
		else {
			return rDepth + 1;
		}
	}
}
int path_length(TNode* root)	//경로의 길이
{
	int max;
	int leftPath, rightPath;
	int leftMax, rightMax;

	if (root == NULL)
		return 0;
	leftPath = treeDepth(root->left);
	rightPath = treeDepth(root->right);
	max = leftPath + rightPath + 1;
	leftMax = path_length(root->left);
	rightMax = path_length(root->right);
	if (leftMax > max) {
		max = leftMax;
	}
	if (rightMax > max) {
		max = rightMax;
	}
	return max;
}

void reverse(TNode* root)	//좌우대칭
{
	TNode* temp;
	if (root == NULL)return;
	temp = root->right;
	root->right = root->left;
	root->left = temp;
	reverse(root->left);
	reverse(root->right);
}
void main()
{
	TNode* b, * c, * d, * e, * f;
	init_tree();
	d = create_tree('D', NULL, NULL);
	c = create_tree('C', NULL, NULL);
	b = create_tree('B', c, d);
	f = create_tree('F', NULL, NULL);
	e = create_tree('E', NULL, f);
	root = create_tree('A', b, e);

	printf("Level-Order :"); levelorder(root);
	printf("\n");
	printf("\n");
	level(root);
	if (is_balanced(root) == 1)
		printf("균형잡힌 트리입니다.\n");
	else
		printf("불균형한 트리입니다.\n");
	printf("전체 경로의 길이는 %d입니다.\n", path_length(root));
	reverse(root);
	printf("\n트리의 좌우를 교환합니다.\n");
	printf("Level-Order :"); levelorder(root);

}
